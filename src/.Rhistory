library(mvtnorm)
mus[1]
mus[,,1]
train.bs[1,-8]
# need to predict using test set .
dmvnorm(train.bs[1,-8],mus[,,1],sigs[,,1])
# mixing proportions
pigs = dp$weight
# mixing proportions
pigs = dp$weights
dp$weights
# mixing proportions
pigs = dp$weights
pigs
# need to predict using test set .
pigs[1]*dmvnorm(train.bs[1,-8],mus[,,1],sigs[,,1])
mm
mm$G
mm$G
mm$BIC
mm$G
table(clus_labels,train.bs$type)
adjustedRandIndex(clus_labels,train.bs$type)
adjustedRandIndex(train.bs$type,mm$classification)
# function
n = dim(train.bs[,-8])[1]
n
# function
n = dim(test.n)[1]
test.n
n
matrix(0,n,7)
zigs = matrix(0,n,7)
G <- length(pigs)
G
# function
n = dim(test.n)[1]
zigs = matrix(0,n,7)
zigs = matrix(0,n,G)
for(i in 1:n){
for(g in 1:G){
zigs[i,g] = pigs[1]*dmvnorm(test.n[i,-8],mus[,,g],sigs[,,g])
}
}
zigs
sum(zigs[i,])
i
for(i in 1:n){
zigs[i,] = zigs[i,]/sum(zigs[i,])
}
zigs
for(i in 1:n){
zigs[i,] = zigs[i,]/sum(zigs[i,])
zigs[i,G] = 1 - zigs[i,1:(G-1)]
}
1 - zigs[i,1:(G-1)]
for(i in 1:n){
for(g in 1:G){
zigs[i,g] = pigs[1]*dmvnorm(test.n[i,-8],mus[,,g],sigs[,,g])
}
}
for(i in 1:n){
zigs[i,] = zigs[i,]/sum(zigs[i,])
zigs[i,G] = 1 - sum(zigs[i,1:(G-1)])
}
rowSums(zigs)
zigs
labs
znaks
# map them
znaks = rep(0,n)
# map them
znaks = rep(0,n)
for(i in 1:n){
znaks[i] = match(max(zigs[i,]),zigs[i,])
}
znaks
table(znaks,test.n$type)
adjustedRandIndex(znaks,test.n$type)
mod
predict_dp <- function(mod, new_data ){
# mixing proportions
pigs <- new_data$weights
G <- length(pigs)
mus <- new_data$clusterParameters$mu
sigs <- new_data$clusterParameters$sig
n = dim(test.n)[1]
zigs = matrix(0,n,G)
for(i in 1:n){
for(g in 1:G){
zigs[i,g] = pigs[1]*dmvnorm(new_data[i,-8],mus[,,g],sigs[,,g])
}
}
for(i in 1:n){
zigs[i,] = zigs[i,]/sum(zigs[i,])
zigs[i,G] = 1 - sum(zigs[i,1:(G-1)])
}
# map them
znaks = rep(0,n)
for(i in 1:n){
znaks[i] = match(max(zigs[i,]),zigs[i,])
}
znaks
}
vlabs <- predict_dp(dp,test.n)
predict_dp <- function(mod, new_data ){
# mixing proportions
pigs <- new_data$weights
G <- length(pigs)
mus <- mod$clusterParameters$mu
sigs <- mod$clusterParameters$sig
n = dim(new_data)[1]
zigs = matrix(0,n,G)
for(i in 1:n){
for(g in 1:G){
zigs[i,g] = pigs[1]*dmvnorm(new_data[i,-8],mus[,,g],sigs[,,g])
}
}
for(i in 1:n){
zigs[i,] = zigs[i,]/sum(zigs[i,])
zigs[i,G] = 1 - sum(zigs[i,1:(G-1)])
}
# map them
znaks = rep(0,n)
for(i in 1:n){
znaks[i] = match(max(zigs[i,]),zigs[i,])
}
znaks
}
vlabs <- predict_dp(dp,test.n)
vlabs <- predict_dp(dp,test.n[,-8])
predict_dp <- function(mod, new_data ){
# mixing proportions
pigs <- mod$weights
G <- length(pigs)
mus <- mod$clusterParameters$mu
sigs <- mod$clusterParameters$sig
n = dim(new_data)[1]
zigs = matrix(0,n,G)
for(i in 1:n){
for(g in 1:G){
zigs[i,g] = pigs[1]*dmvnorm(new_data[i,-8],mus[,,g],sigs[,,g])
}
}
for(i in 1:n){
zigs[i,] = zigs[i,]/sum(zigs[i,])
zigs[i,G] = 1 - sum(zigs[i,1:(G-1)])
}
# map them
znaks = rep(0,n)
for(i in 1:n){
znaks[i] = match(max(zigs[i,]),zigs[i,])
}
znaks
}
vlabs <- predict_dp(dp,test.n[,-8])
vlabs
table(vlabs,test.n$type)
adjustedRandIndex(vlabs,test.n$type)
mm$parameters$mean
mm$parameters$variance
help(UpdateAlpha)
help("DirichletProcessMvnormal")
# MSE for dirichlet processes
# first one is default
potential_priors <- list(c(2,4),c(1,2),c(3,5),c(3,3))
prior
rand(10)
rnorm(10)
rnorm(10)
rnorm(10)
mse_dp <- function(prior)
{
ari_class <- rep(0,50)
# boot strap draws 50 times
for(z in 1:50){
pima <- rbind(Pima.tr,Pima.te)
## Pairs plot for the two groups
pairs <- ggpairs(pima[,-8], aes(colour = pima$type ))
pairs
# Scale
pima[,-8] <- scale(pima[,-8])
# classes are not even so I am going to do bootstrap
# sampling to create my own training set
set.seed(15)
len_pima <- dim(pima)[1]
ind_train <- sample(1:len_pima, as.integer(len_pima*0.80))
train.n <- pima[ind_train,]
test.n  <- pima[-ind_train,]
# scaling some stuff
train.n[,-8] <- scale(train.n[,-8])
test.n[,-8] <- scale(test.n[,-8])
#fit the model
dp <- DirichletProcessMvnormal(as.matrix(train.bs[,-8]),alphaPriors = )
dp <- Fit(dp, 1000)
clus_labels <- dp$clusterLabels # get the cluster labels from the training set
# using the custom function get the predictions on the test set
vlabs <- predict_dp(dp,test.n[,-8])
# get the ari and allocate to the the vector keeping track of it
ari_class[z] <- adjustedRandIndex(vlabs,test.n$type)
}
# return the ari_class
ari_class
}
ari_boot_dp <- function(prior)
{
ari_class <- rep(0,50)
# boot strap draws 50 times
for(z in 1:50){
pima <- rbind(Pima.tr,Pima.te)
## Pairs plot for the two groups
pairs <- ggpairs(pima[,-8], aes(colour = pima$type ))
pairs
# Scale
pima[,-8] <- scale(pima[,-8])
# classes are not even so I am going to do bootstrap
# sampling to create my own training set
set.seed(15)
len_pima <- dim(pima)[1]
ind_train <- sample(1:len_pima, as.integer(len_pima*0.80))
train.n <- pima[ind_train,]
test.n  <- pima[-ind_train,]
# scaling some stuff
train.n[,-8] <- scale(train.n[,-8])
test.n[,-8] <- scale(test.n[,-8])
#fit the model
dp <- DirichletProcessMvnormal(as.matrix(train.bs[,-8]),alphaPriors = )
dp <- Fit(dp, 1000)
clus_labels <- dp$clusterLabels # get the cluster labels from the training set
# using the custom function get the predictions on the test set
vlabs <- predict_dp(dp,test.n[,-8])
# get the ari and allocate to the the vector keeping track of it
ari_class[z] <- adjustedRandIndex(vlabs,test.n$type)
}
# return the ari_class
ari_class
}
ari_boot_dp <- function(prior,num_boots = 50)
{
ari_class <- rep(0,num_boots)
# boot strap draws 50 times
for(z in 1:num_boots){
pima <- rbind(Pima.tr,Pima.te)
## Pairs plot for the two groups
pairs <- ggpairs(pima[,-8], aes(colour = pima$type ))
pairs
# Scale
pima[,-8] <- scale(pima[,-8])
# classes are not even so I am going to do bootstrap
# sampling to create my own training set
set.seed(15)
len_pima <- dim(pima)[1]
ind_train <- sample(1:len_pima, as.integer(len_pima*0.80))
train.n <- pima[ind_train,]
test.n  <- pima[-ind_train,]
# scaling some stuff
train.n[,-8] <- scale(train.n[,-8])
test.n[,-8] <- scale(test.n[,-8])
#fit the model
dp <- DirichletProcessMvnormal(as.matrix(train.bs[,-8]),alphaPriors = )
dp <- Fit(dp, 1000)
clus_labels <- dp$clusterLabels # get the cluster labels from the training set
# using the custom function get the predictions on the test set
vlabs <- predict_dp(dp,test.n[,-8])
# get the ari and allocate to the the vector keeping track of it
ari_class[z] <- adjustedRandIndex(vlabs,test.n$type)
}
# return the ari_class
ari_class
}
# test function for results
rez_2 <- ari_boot_dp(c(1,2),num_boots = 2)
rez_2
ari_boot_dp <- function(prior,num_boots = 50)
{
ari_class <- rep(0,num_boots)
# boot strap draws 50 times
for(z in 1:num_boots){
pima <- rbind(Pima.tr,Pima.te)
## Pairs plot for the two groups
pairs <- ggpairs(pima[,-8], aes(colour = pima$type ))
pairs
# Scale
pima[,-8] <- scale(pima[,-8])
# classes are not even so I am going to do bootstrap
# sampling to create my own training set
len_pima <- dim(pima)[1]
ind_train <- sample(1:len_pima, as.integer(len_pima*0.80))
train.n <- pima[ind_train,]
test.n  <- pima[-ind_train,]
# scaling some stuff
train.n[,-8] <- scale(train.n[,-8])
test.n[,-8] <- scale(test.n[,-8])
#fit the model
dp <- DirichletProcessMvnormal(as.matrix(train.bs[,-8]),alphaPriors = )
dp <- Fit(dp, 1000)
clus_labels <- dp$clusterLabels # get the cluster labels from the training set
# using the custom function get the predictions on the test set
vlabs <- predict_dp(dp,test.n[,-8])
# get the ari and allocate to the the vector keeping track of it
ari_class[z] <- adjustedRandIndex(vlabs,test.n$type)
}
# return the ari_class
ari_class
}
# test function for results
# each run takes approximately 8 minutes.
rez_2 <- ari_boot_dp(c(1,2),num_boots = 2)
rez_2
library(parallel)
parApply(1:10)
help("parallel")
help("parApply")
cl <- makeCluster(getOption("cl.cores",50))
cl
clusterApply(cl, 1:2, get("+"), 3)
clusterApply(cl, 1:3, function(x){x^2})
clusterApply(cl, 1:3, function(x){"hello"})
clusterApply(cl, 1:3, function(x){"hello"}) %>% unlist
ari_boot_par_dp <- function(prior,num_boots = 50)
{
# boot strap draws 50 times
run_model <- function(b_id){
pima <- rbind(Pima.tr,Pima.te)
## Pairs plot for the two groups
pairs <- ggpairs(pima[,-8], aes(colour = pima$type ))
pairs
# Scale
pima[,-8] <- scale(pima[,-8])
# classes are not even so I am going to do bootstrap
# sampling to create my own training set
len_pima <- dim(pima)[1]
ind_train <- sample(1:len_pima, as.integer(len_pima*0.80))
train.n <- pima[ind_train,]
test.n  <- pima[-ind_train,]
# scaling some stuff
train.n[,-8] <- scale(train.n[,-8])
test.n[,-8] <- scale(test.n[,-8])
#fit the model
dp <- DirichletProcessMvnormal(as.matrix(train.bs[,-8]),alphaPriors = )
dp <- Fit(dp, 1000)
clus_labels <- dp$clusterLabels # get the cluster labels from the training set
# using the custom function get the predictions on the test set
vlabs <- predict_dp(dp,test.n[,-8])
# get the ari and allocate to the the vector keeping track of it
adjustedRandIndex(vlabs,test.n$type)
}
ari_cluster <- clusterApply(cl,1:num_boots,run_model)
ari_class <- unlist(ari_cluster)
}
ari_boot_par_dp(c(1,2),num_boots = 2)
library(MASS) # load PIMA dataset
library(mclust) # mclust for clustering.
library(ggplot2) # plotting stuff
library(GGally) # more plotting stuff
library(dplyr)
library(mvtnorm)
ari_boot_par_dp(c(1,2),num_boots = 2)
mcmapply(function(x) x^2,1:2)
mcmapply(function(x) x^2,1:3)
ari_boot_par_dp <- function(prior,num_boots = 50)
{
# boot strap draws 50 times
run_model <- function(b_id){
pima <- rbind(Pima.tr,Pima.te)
## Pairs plot for the two groups
pairs <- ggpairs(pima[,-8], aes(colour = pima$type ))
pairs
# Scale
pima[,-8] <- scale(pima[,-8])
# classes are not even so I am going to do bootstrap
# sampling to create my own training set
len_pima <- dim(pima)[1]
ind_train <- sample(1:len_pima, as.integer(len_pima*0.80))
train.n <- pima[ind_train,]
test.n  <- pima[-ind_train,]
# scaling some stuff
train.n[,-8] <- scale(train.n[,-8])
test.n[,-8] <- scale(test.n[,-8])
#fit the model
dp <- DirichletProcessMvnormal(as.matrix(train.bs[,-8]),alphaPriors = )
dp <- Fit(dp, 1000)
clus_labels <- dp$clusterLabels # get the cluster labels from the training set
# using the custom function get the predictions on the test set
vlabs <- predict_dp(dp,test.n[,-8])
# get the ari and allocate to the the vector keeping track of it
adjustedRandIndex(vlabs,test.n$type)
}
ari_cluster <- mcmapply(run_model, 1:num_boots,num_boots) # clusterApply(cl,1:num_boots,run_model)
ari_class <- unlist(ari_cluster)
}
ari_boot_dp(c(1,2),2)
unlist(c(1,2,3))
list(1)
append(list(1),list(2))
append(list(1),list(3))
parallel
pack
install_packs <- function(){
packs <- c("MASS","mclust","ggplot2","GGally","dplyr",
"mvtnorm","dirichletprocess","parallel" )
for(pack in packs){
install.packages(pack)
}
}
run_model
# i had to parallize this because it ran too long serially.
ari_boot_par_dp <- function(prior,num_boots = 50)
{
# boot strap draws 50 times
run_model <- function(b_id){
pima <- rbind(Pima.tr,Pima.te)
## Pairs plot for the two groups
pairs <- ggpairs(pima[,-8], aes(colour = pima$type ))
pairs
# Scale
pima[,-8] <- scale(pima[,-8])
# classes are not even so I am going to do bootstrap
# sampling to create my own training set
len_pima <- dim(pima)[1]
ind_train <- sample(1:len_pima, as.integer(len_pima*0.80))
train.n <- pima[ind_train,]
test.n  <- pima[-ind_train,]
# scaling some stuff
train.n[,-8] <- scale(train.n[,-8])
test.n[,-8] <- scale(test.n[,-8])
#fit the model
dp <- DirichletProcessMvnormal(as.matrix(train.bs[,-8]),alphaPriors = )
dp <- Fit(dp, 1000)
clus_labels <- dp$clusterLabels # get the cluster labels from the training set
# using the custom function get the predictions on the test set
vlabs <- predict_dp(dp,test.n[,-8])
# get the ari and allocate to the the vector keeping track of it
adjustedRandIndex(vlabs,test.n$type)
}
ari_cluster <- mcmapply(run_model, 1:num_boots,num_boots) # clusterApply(cl,1:num_boots,run_model)
ari_class <- unlist(ari_cluster)
}
rezlts <- list()
for(pr in potential_priors){
rezlts <- append(rezlts,ari_boot_par_dp(c(1,2),50))
}
# i had to parallize this because it ran too long serially.
ari_boot_par_dp <- function(prior,num_boots = 50)
{
# boot strap draws 50 times
run_model <- function(b_id){
pima <- rbind(Pima.tr,Pima.te)
## Pairs plot for the two groups
pairs <- ggpairs(pima[,-8], aes(colour = pima$type ))
pairs
# Scale
pima[,-8] <- scale(pima[,-8])
# classes are not even so I am going to do bootstrap
# sampling to create my own training set
len_pima <- dim(pima)[1]
ind_train <- sample(1:len_pima, as.integer(len_pima*0.80))
train.n <- pima[ind_train,]
test.n  <- pima[-ind_train,]
# scaling some stuff
train.n[,-8] <- scale(train.n[,-8])
test.n[,-8] <- scale(test.n[,-8])
#fit the model
dp <- DirichletProcessMvnormal(as.matrix(train.bs[,-8]),alphaPriors = prior )
dp <- Fit(dp, 1000)
clus_labels <- dp$clusterLabels # get the cluster labels from the training set
# using the custom function get the predictions on the test set
vlabs <- predict_dp(dp,test.n[,-8])
# get the ari and allocate to the the vector keeping track of it
adjustedRandIndex(vlabs,test.n$type)
}
ari_cluster <- mcmapply(run_model, 1:num_boots,2) # clusterApply(cl,1:num_boots,run_model)
ari_class <- unlist(ari_cluster)
}
rezlts <- list()
for(pr in potential_priors){
rezlts <- append(rezlts,ari_boot_par_dp(c(1,2),50))
}
ari_boot_dp <- function(prior,num_boots = 50)
{
ari_class <- rep(0,num_boots)
# boot strap draws 50 times
for(z in 1:num_boots){
pima <- rbind(Pima.tr,Pima.te)
# Scale
pima[,-8] <- scale(pima[,-8])
# classes are not even so I am going to do bootstrap
# sampling to create my own training set
len_pima <- dim(pima)[1]
ind_train <- sample(1:len_pima, as.integer(len_pima*0.80))
train.n <- pima[ind_train,]
test.n  <- pima[-ind_train,]
# scaling some stuff
train.n[,-8] <- scale(train.n[,-8])
test.n[,-8] <- scale(test.n[,-8])
#fit the model
dp <- DirichletProcessMvnormal(as.matrix(train.bs[,-8]),alphaPriors = )
dp <- Fit(dp, 1000)
clus_labels <- dp$clusterLabels # get the cluster labels from the training set
# using the custom function get the predictions on the test set
vlabs <- predict_dp(dp,test.n[,-8])
# get the ari and allocate to the the vector keeping track of it
ari_class[z] <- adjustedRandIndex(vlabs,test.n$type)
}
# return the ari_class
ari_class
}
# test function for results
# each run takes approximately 8 minutes. times 50 times x number of priors is a very long time
rez_12 <- ari_boot_dp(c(1,2),num_boots = 50)
ari_class
ari_class
